= How to call a Kubernetes Service on OpenShift
:hp-tags: OpenShift, Fabric8, Kubernetes

_Summery_ - 

== Introduction

We use Openshift as our Kubernetes implementation. 

Before we talk about calling a service, let's first talk about deploying a service. Let's say we have created a RESTful service, and we'd like to deploy it to Kubernetes. The easiest way to do this is using the http://fabric8.io/gitbook/mavenPlugin.html[fabric8 maven plugin] in your pom. Along with the https://github.com/rhuss/docker-maven-plugin [docker maven plugin], it allows create a docker container running your service with just setting a few configuration properties. For some ready to go examples see the https://github.com/fabric8io/ipaas-quickstarts [Fabric8 iPaas quickstarts]. We're not going to talk about the specifics, but at a high level what happens is that your service is wrapped inside a Docker image. This image is uploaded under the https://hub.docker.com/u/fabric8/[fabric8 user on dockerhub]. Note that the docker user is configured in the pom and if you'd prefer to use a private docker registry you can `set export DOCKER_REGISTRY=172.30.17.90:5000/TCP`. The fabric8 maven plugin also creates the configuration artifacts needed by Kubernetes which are a 'template', a 'service' and a 'replication-controler' configuration files formatted in JSON. The template references the docker image and when the template is deployed to kubernetes, kubernetes can instantiate a new instance of the service by instructing Docker to start up a new container based on the docker image. In most quickstarts you can do this all at once using `mvn -Pf8-local-deploy`. So let's assume you managed all of this and you can see your new shiny service running in the Fabric8 console and now you want clients to call it. Depending on wether the client is part of the kubernetes domain or not and if you want to use the apiman gateway for this there are a few different scenarios.

== Scenario 1 - K8s Client to K8s Service

In scenario 1 the client is a service on kubernetes and you want to invoke another service in same kubernetes domain. This scenario is depicted in figure 1. 

image::k8s-service-scenario-1.png[]
[caption="Figure 1: "]
.Kubernetes Client A invoking Kubernetes Service C.

The client service can use the system paramaters set in the docker container to find the `host` and `port` settings of Service C in the kubernetes domain. When invoking this service endpoint the service proxy connects to a one of the pods running behind the service. By default the service proxy tries to find local pods first (`local` meaning `on the same node`). The fragment below show

....
String serviceName = "C";
String host = KubernetesServices.serviceToHostOrBlank(serviceName);
String port = KubernetesServices.serviceToPortOrBlank(serviceName);
....

Or if you prefer a canonical name instead of the IP address, then do a DNS lookup, which returns a string formatted like
`<service-name>.<k8s-domain>.svc.cluster.local` or `<service-name>.<k8s-domain>` for short.
....
InetAddress initAddress = InetAddress.getByName("C");
String host = initAddress.getCanonicalHostName();
....           


Note that the IP address returned, and the canonical address of `<service-name>.<k8s-domain>` can *only* be used on the kubernetes cluster and can *not* be used externally. If Client A is externally keep reading scenario 2.


== Scenario 2 - External Client to K8s


image::k8s-service-scenario-2.png[]
[caption="Figure 2: "]
.External Client A invoking Kubernetes Service C.

== Scenario 3 - K8s Client to K8s Service via the APIMan Gateway

image::k8s-service-scenario-3.png[]
[caption="Figure 3: "]
.Kubernetes Client A invoking Kubernetes Service C via the APIMan Gateway.

== Scanario 4 - External Client to K8s Service via the APIMan Gateway

image::k8s-service-scenario-4.png[]
[caption="Figure 4: "]
.External Client A invoking Kubernetes Service C via the APIMan Gateway.